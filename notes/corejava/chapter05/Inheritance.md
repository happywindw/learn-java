#Chapter 5: Inheritance

###5.1 Classes, Superclasses, and Subclasses  
- “is-a”关系是继承的一个明显特征。  
- 继承关系中，已存在的类称为超类（superclass）、基类（base class）或父类（parent class）；新类称为子类（subclass）、派生类（derived class）或孩子类（child class）。  
- 子类调用父类方法需使用super关键字。  
- 子类不能访问父类的私有域，初始化父类的私有域需要调用父类构造器。使用super调用构造器的语句必须是子类构造器中的第一条语句。  
- 若子类没有显式的调用父类的构造器，java会自动调用父类的默认无参构造器。若父类没有默认构造器，会产生编译错误。
- this关键字的两个用途：一是引用隐式参数；二是调用该类其他的构造器。  
- super关键字的两个用途：一是调用超类方法；二是调用超类构造器。  
- 一个对象变量可以指示多种实际类型的现象被称为多态（polymorphism）。在运行时能够自动地选择调用哪个方法的现象称为动态绑定（dynamic binding）。  
- 由一个公共超类派生出来的所有类的集合被称为继承层次（inheritance hierarchy）。在继承层次中，从某个特定的类到其祖先的路径被称为该类的继承链（inheritance chain）。  
- 方法的名字和参数列表称为方法的签名。返回类型不是签名的一部分。  
- 动态绑定时若每次都搜索调用方法将十分耗时。因此，虚拟机预先为每个类创建了一个方法表（method table），其中列出了所有方法的签名和实际调用方法。  
- 动态绑定的执行过程：  
  1. 编译器获取对象的声明类型和需要调用的方法名称。提取出该对象实际类型的方法表。  
  2. 虚拟机根据需调用方法的签名搜索应具体调用哪一个方法，这个过程被称为重载解析（overloading resolution）。  
  3. 调用该方法。  
- 静态绑定是指程序调用private、final、static类型的方法或者构造器时，编译器可以准确的知道应该调用哪个方法。  
- 声明为final的类无法被继承，声明为final的方法无法被覆盖。final类中的方法也都是final的，但不包括域。  
- 将一个类或者方法声明为final的主要目的是：确保它们不会在子类中改变语义。  
- 将一个超类的引用赋给一个子类变量时，必须进行类型转换，这样才能通过运行时检查。  
- 对象之间只有通过了instanceof运算符检查的类型转换才能够成功。一般应尽量少用向下的类型转换和instanceof运算符。  
- 只能在继承层次内进行类型转换。  
- 包含一个或多个抽象方法的类本身必须被声明为抽象类。除了抽象方法外，抽象类还可以包含具体数据和具体方法。  
- 一个类即使不包含抽象方法，也可以被声明为抽象类。抽象类不可以被实例化。  
- 控制可见性的4个修饰符：  
  1. private —— 对本类可见；  
  2. public —— 对所有类可见；  
  3. protected —— 对本包和子类可见；  
  4. 不加修饰符 —— 对本包可见。
